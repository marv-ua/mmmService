#Область ПрограммныйИнтерфейс

#Область Интерфейсные

// Вычисляет сумму выделенных ячеек табличного документа.
//
// Параметры:
//	Сумма - Число - Сумма значений ячеек.
//	СтруктураАдресВыделеннойОбласти - Структура - Содержит ячейки выделенной области.
//	Результат - ТабличныйДокумент - Табличный документ, содержащий ячейки для суммирования.
//
Процедура ВычислитьСуммуВЯчейках(Сумма, СтруктураАдресВыделеннойОбласти, Результат) Экспорт
	Перем РазделительДробнойЧасти;
	
	Если Не СтруктураАдресВыделеннойОбласти.Свойство("РазделительДробнойЧасти", РазделительДробнойЧасти) Тогда
		ЭталонноеЧисло = Формат(1.1);
		РазделительДробнойЧасти = ?(СтрДлина(ЭталонноеЧисло) > 3, "", Сред(ЭталонноеЧисло, 2, 1));
	КонецЕсли;

	Для ИндексСтрока = СтруктураАдресВыделеннойОбласти.Верх По СтруктураАдресВыделеннойОбласти.Низ Цикл
		Если ИндексСтрока = 0 Тогда // Выделена колонка отчета (без ограничений), суммы из нее получить нельзя.
			Продолжить;
		КонецЕсли;
		
		Для ИндексКолонка = СтруктураАдресВыделеннойОбласти.Лево По СтруктураАдресВыделеннойОбласти.Право Цикл
			Если ИндексКолонка = 0 Тогда // Выделена строка отчета (без ограничений), суммы из нее получить нельзя.
				Продолжить;
			КонецЕсли;
			
			Ячейка = Результат.Область(ИндексСтрока, ИндексКолонка, ИндексСтрока, ИндексКолонка);
			Если Ячейка.Видимость <> Истина Тогда
				Продолжить;
			КонецЕсли;
			
			Если Ячейка.СодержитЗначение И ТипЗнч(Ячейка.Значение) = Тип("Число") Тогда
				Сумма = Сумма + Ячейка.Значение;
				Продолжить;
			ИначеЕсли Не ЗначениеЗаполнено(Ячейка.Текст) Тогда
				Продолжить;
			КонецЕсли;

			Сумма = Сумма + СтрокаСФорматомВЧисло(Ячейка.Текст, РазделительДробнойЧасти);
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти 

#Область Вспомогательные

// Возвращает имя отчета (объекта метаданных), которому принадлежит форма.
// Следует использовать для форм, принадлежащих отчету.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма объекта.
//
// Возвращаемое значение:
//	Строка       - Имя отчета (объекта метаданных).
//  Неопределено - Передана не форма отчета (например, если отчет использует общую форму).
//
Функция ИмяОтчетаПоИмениФормы(Форма) Экспорт
	
	ЭлементыИмени = СтрРазделить(Форма.ИмяФормы, ".");
	Если ЭлементыИмени.Количество() > 1 И ЭлементыИмени[0] = "Отчет" Тогда
		Возврат ЭлементыИмени[1];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// Возвращает наименование фонового задания для выполнения отчета.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма отчета.
//
// Возвращаемое значение:
//	Строка - Наименование фонового задания.
//
Функция ПолучитьНаименованиеЗаданияВыполненияОтчета(Форма, ИмяОтчета = "") Экспорт
	
	НаименованиеЗадания = НСтр("ru = 'Выполнение отчета: %1'");
	
	Если ПустаяСтрока(ИмяОтчета) Тогда
		ИмяОтчета = ИмяОтчетаПоИмениФормы(Форма);
	КонецЕсли;
	
	НаименованиеЗадания = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НаименованиеЗадания, ИмяОтчета);
	
	Возврат НаименованиеЗадания;
	
КонецФункции

// Возвращает имена разделов настроек стандартного отчета.
// 
// Возвращаемое значение:
//  Структура - Ключ - имя раздела настроек стандартного отчета, значение - флаг заполнения настроек по умолчанию.
//
Функция РазделыНастроекСтандартногоОтчета() Экспорт
	
	РазделыНастроек = Новый Структура();
	
	РазделыНастроек.Вставить("Группировка", 		Ложь);
	РазделыНастроек.Вставить("Отбор", 				Ложь);
	РазделыНастроек.Вставить("Показатели", 			Ложь);
	РазделыНастроек.Вставить("ДополнительныеПоля", 	Ложь);
	РазделыНастроек.Вставить("УсловноеОформление", 	Ложь);
	
	Возврат РазделыНастроек;
	
КонецФункции

// Проверяет поддерживает ли отчет обмен универсальными настройками (см. НовыйУниверсальныеНастройки).
//
// Параметры:
//  ИмяОтчета - Строка - Имя проверяемого отчета.
// 
// Возвращаемое значение:
//   Булево - Истина, если поддерживает, в противном случае - Ложь.
//
Функция ОтчетПоддерживаетУниверсальныеНастройки(ИмяОтчета) Экспорт
	
	СписокОтчетов = Новый Массив;
	СписокОтчетов.Добавить("АнализСубконто");
	СписокОтчетов.Добавить("АнализСчета");
	СписокОтчетов.Добавить("КарточкаСубконто");
	СписокОтчетов.Добавить("КарточкаСчета");
	СписокОтчетов.Добавить("ОборотноСальдоваяВедомость");
	СписокОтчетов.Добавить("ОборотноСальдоваяВедомостьПоСчету");
	СписокОтчетов.Добавить("ОборотыМеждуСубконто");
	СписокОтчетов.Добавить("ОборотыСчета");
	СписокОтчетов.Добавить("ОтчетПоПроводкам");
	СписокОтчетов.Добавить("СводныеПроводки");
	СписокОтчетов.Добавить("ШахматнаяВедомость");
	
	Возврат СписокОтчетов.Найти(ИмяОтчета) <> Неопределено;
	
КонецФункции

// Проверяет в форме отчета, использует ли она отложенную инициализацию компоновщика настроек.
// Критерий проверки - наличие реквизита КомпоновщикИнициализирован формы отчета.
//
// Если используется отложенная инициализация, то в ходе работы пользователя с формой отчета требуется вызов.
// БухгалтерскиеОтчетыВызовСервера.ИнициализацияКомпоновщикаНастроек
//
// Другим критерием может быть наличие у отчета двух схем - 
// для инициализации при создании формы используется основная пустая схема.
//
// Отчет, использующий отложенную инициализацию компоновщика настроек должен в составе реквизитов иметь
// реквизит ПользовательскиеНастройки для хранения адреса, по которому размещены настройки для передачи
// между компонентами механизма отложенной инициализации.
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения - форма отчета.
// 
// Возвращаемое значение:
//  Булево - Истина, если отчет использует отложенную инициализацию компоновщика настроек.
//
Функция ОтчетИспользуетОтложеннуюИнициализациюКомпоновщикаНастроек(Форма) Экспорт
	
	Возврат ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма, "КомпоновщикИнициализирован");
	
КонецФункции

// Проверяет, является ли указанное значение простым типом данных.
//
// Параметры:
// 	Значение - Произвольный - Проверяемое значение.
//
// Возвращаемое значение:
//	Булево - Истина, если значение простого типа, иначе Ложь.
//
Функция ПростойТип(Значение) Экспорт
	
	ОписаниеПростыхТипов = Новый ОписаниеТипов("Дата, Строка, Булево, Число");
	
	Возврат ОписаниеПростыхТипов.СодержитТип(ТипЗнч(Значение));
	
КонецФункции


// Дает возможность работать с произвольными разделителем дробной части и разделителем групп разрядов.
// Также как и СтроковыеФункцииКлиентСервер.СтрокаВЧисло() работает без выдачи исключений.
//
// Параметры:
//  Значение - Строка - Строка, которую необходимо привести к числу.
//  РазделительДробнойЧасти - Строка - Символ, который является разделителем дробной части. Если не указан, то будет
//             использован первый символ отличный от цифры в ряду символов справа. Например, и "ъ111,222.333ъ" ,
//             и "111,222,333" будут распознаны как 111222.333 , если разделитель не указан явно; но, если указан
//             разделитель "," , то будут распознаны соответственно как 111.222333 и 111222.333
//
// Возвращаемое значение:
//   Число - распознанное число или 0, если не удалось распознать.
//
Функция СтрокаСФорматомВЧисло(Знач Значение, РазделительДробнойЧасти = "") Экспорт
	
	Если ПустаяСтрока(Значение) Тогда
		Возврат 0;
	КонецЕсли;
	
	ДлинаЗначения = СтрДлина(Значение);
	Если ДлинаЗначения = 1 И Не СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Значение) Тогда
		// Отдельно обрабатываем тривиальный случай. Например, "-" .
		Возврат 0;
	КонецЕсли;
	
	// Определяем самую левую и самую правую из цифр строки.
	Для ЛеваяГраница = 1 По ДлинаЗначения Цикл
		ТекущийСимвол = Сред(Значение, ЛеваяГраница, 1);
		Если ТекущийСимвол >= "0" И ТекущийСимвол <= "9" Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Для ПраваяГраница = 0 По ДлинаЗначения - 1 Цикл
		ТекущийСимвол = Сред(Значение, ДлинаЗначения - ПраваяГраница, 1);
		Если ТекущийСимвол >= "0" И ТекущийСимвол <= "9" Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	ПраваяГраница = ДлинаЗначения - ПраваяГраница;
	Если ПраваяГраница < ЛеваяГраница Тогда
		// В строке вообще отсутствуют цифры.
		Возврат 0;
	КонецЕсли;
	
	// Определяем знак числа.
	Если СтрНайти(Значение, "-", НаправлениеПоиска.СКонца, ЛеваяГраница) <> 0   // соответствует форматам ЧО=3 или ЧО=4
	 Или СтрНайти(Значение, "-", НаправлениеПоиска.СНачала, ПраваяГраница) <> 0 // соответствует форматам ЧО=1 или ЧО=2
	 Или СтрНайти(Значение, "(", НаправлениеПоиска.СКонца, ЛеваяГраница) <> 0   // соответствует формату ЧО=0
		И СтрНайти(Значение, ")", НаправлениеПоиска.СНачала, ПраваяГраница) <> 0 Тогда
		ЗнакЗначения = -1;
	Иначе
		ЗнакЗначения = 1;
	КонецЕсли;
	
	Если ПраваяГраница <> ДлинаЗначения Или ЛеваяГраница <> 1 Тогда
		ДлинаЗначения = ПраваяГраница - ЛеваяГраница + 1;
		Значение = Сред(Значение, ЛеваяГраница, ДлинаЗначения);
	КонецЕсли;
	
	// Определяем дробную часть числа.
	ТолькоЦифры = Новый Массив;
	РазделительНайден = Ложь;
	РазрядовПослеЗапятой = 0;
	Для НомерСимвола = 0 По ДлинаЗначения - 1 Цикл
		
		ТекущийСимвол = Сред(Значение, ДлинаЗначения - НомерСимвола, 1);
		
		ЭтоЦифра = (ТекущийСимвол >= "0" И ТекущийСимвол <= "9");
		Если ЭтоЦифра Тогда
			ТолькоЦифры.Вставить(0, ТекущийСимвол);
		КонецЕсли;
		
		Если РазделительНайден Тогда
			Продолжить;
		КонецЕсли;
			
		Если ЭтоЦифра Тогда
			РазрядовПослеЗапятой = РазрядовПослеЗапятой + 1;
		ИначеЕсли ПустаяСтрока(РазделительДробнойЧасти)
		 Или ТекущийСимвол = РазделительДробнойЧасти Тогда
			РазделительНайден = Истина;
		КонецЕсли;

	КонецЦикла;
	Если Не РазделительНайден Тогда // строка не содержит дробной части
		РазрядовПослеЗапятой = 0;
	КонецЕсли;
	
	// Преобразуем в число с учетом дробной части.
	ТипЧисло = Новый ОписаниеТипов("Число");
	ЗначениеТолькоЦифры = СтрСоединить(ТолькоЦифры);
	Результат = ЗнакЗначения * ТипЧисло.ПривестиЗначение(ЗначениеТолькоЦифры);
	Если РазрядовПослеЗапятой <> 0 И ЗначениеЗаполнено(Результат) Тогда
		Результат = Результат / Pow(10, РазрядовПослеЗапятой);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти 

#КонецОбласти 